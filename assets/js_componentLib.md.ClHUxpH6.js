import{_ as e,c as r,o as a,a4 as t}from"./chunks/framework.JknIMk6Q.js";const b=JSON.parse('{"title":"扩展组件库","description":"","frontmatter":{},"headers":[],"relativePath":"js/componentLib.md","filePath":"js/componentLib.md"}'),l={name:"js/componentLib.md"},o=t('<h1 id="扩展组件库" tabindex="-1">扩展组件库 <a class="header-anchor" href="#扩展组件库" aria-label="Permalink to &quot;扩展组件库&quot;">​</a></h1><ul><li><a href="https://blog.csdn.net/qq278672818/article/details/134767652" target="_blank" rel="noreferrer">如何二次封装一个Vue3组件库？</a></li><li><a href="https://blog.csdn.net/qq_41581588/article/details/125866277" target="_blank" rel="noreferrer">使用 Vite 和 TypeScript 从零打造一个属于自己的 Vue3 组件库</a></li></ul><h2 id="封装组件库" tabindex="-1">封装组件库 <a class="header-anchor" href="#封装组件库" aria-label="Permalink to &quot;封装组件库&quot;">​</a></h2><p>开发npm包与开发前端页面工程不同，对于依赖有着更精细的控制：</p><ul><li>开发前端页面工程 <ul><li>安装到dependencies和devDependencies无区别。因为工程都要经过构建成dist成果物，本身是不需要依赖安装的。因此前端需要安装依赖的只有开发模式。</li></ul></li><li>开发npm包： <ul><li>开发模式，生产模式有区别，依赖还区分作为自身依赖还是宿主依赖。</li></ul></li></ul><p><code>dependencies</code>生产依赖 这类依赖在开发环境，生产环境都会被安装。在npm包被集成到宿主工程时，会作为npm包本身的依赖被安装。</p><p><code>devDependencies</code>开发依赖 只在开发环境被安装的依赖，生产环境不安装。在npm包被集成到宿主工程时，也不会被安装。</p><p><code>peerDependencies</code>对等依赖 我觉得也可以叫做“宿主依赖”。这类依赖在开发环境会被安装，但生产构建时不会打包进成果物中。在npm包被集成到宿主工程时，也不会被安装（npm部分版本会自动安装）。但是会提示要求宿主工程本身安装这个依赖。</p><p>封装组件库</p><ol><li>需要构建流程</li><li>不需要构建流程</li></ol><h2 id="monorepo" tabindex="-1">monorepo <a class="header-anchor" href="#monorepo" aria-label="Permalink to &quot;monorepo&quot;">​</a></h2><p>Monorepo <b style="color:red;">是一种项目代码管理方式 </b><br> 中文：多包存储库。就是单个项目仓库 (repository)，其中包含多个开发项目 project (模块 module，或包 package)。虽然这些 project 也许是相关联的，但它们通常在逻辑上相互独立，并被不同的团队负责编写，运行。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>个人认为 Monoreop 实质就是 组件（依赖）抽离。即，将多个项目的公共依赖抽取到特定位置，使得项目不必重复安装和维护公共组件（依赖）。<br> 比如，有多个 Vue 项目都依赖一个公共的组件库 element-plus。如果采用 ==multirepo==，那么此时在每个项目的根目录中就需要多次安装 element-plus。<br> 更复杂一点的场景，如果 我们对 element-plus 中 Table 组件进行了二次封装，那么就需要在每个项目中都需要写封装代码。特别是，涉及到公共组件的bug修复，不可避免地需要修改多个项目的相同组件。<br> 如果采用 ==monorepo==，此时只需要在根目录下载一次 element-plus，多个项目就能够使用该组件。对于公共组件的封装和修改也是一样。</p></div><h3 id="实现工具" tabindex="-1">实现工具 <a class="header-anchor" href="#实现工具" aria-label="Permalink to &quot;实现工具&quot;">​</a></h3><p><a href="https://blog.csdn.net/xgangzai/article/details/137031474" target="_blank" rel="noreferrer">突破项目瓶颈：2024 年 Monorepo 工具选择和实践</a> ——&gt; 更推荐 PNPM</p><ol><li>PNPM <ul><li><a href="https://mp.weixin.qq.com/s/UXH2MMppJN_4tigckAefJw" target="_blank" rel="noreferrer">深度好文——基于 PNPM Monorepo 的组件库研发方案调研</a></li></ul></li><li>Turborepo <ul><li><a href="https://www.zhihu.com/question/505956571" target="_blank" rel="noreferrer">Turborepo</a> Turborepo 是针对 Monorepo 的增强工具,一个为 monorepo 而生的极快的构建系统</li><li><a href="https://lerna.js.org/" target="_blank" rel="noreferrer">lerna.js.org</a></li></ul></li><li>lerna <ul><li><a href="https://blog.51cto.com/u_15506823/6215754" target="_blank" rel="noreferrer">lerna 还是 pnpm + changesets？monorepo 工具核心就看这三个功能</a></li><li><a href="https://gitcode.gitcode.host/docs-cn/lerna-docs-cn/print.html" target="_blank" rel="noreferrer">文档</a></li></ul></li><li>??可以使用<code>git submodule</code>??</li></ol><h3 id="pnpm" tabindex="-1"><a href="./packageManager.html#workspace">pnpm</a> <a class="header-anchor" href="#pnpm" aria-label="Permalink to &quot;[pnpm](./packageManager#workspace)&quot;">​</a></h3><h2 id="vitepress" tabindex="-1">vitePress <a class="header-anchor" href="#vitepress" aria-label="Permalink to &quot;vitePress&quot;">​</a></h2><h3 id="dumi" tabindex="-1"><a href="https://d.umijs.org/" target="_blank" rel="noreferrer">dumi</a> <a class="header-anchor" href="#dumi" aria-label="Permalink to &quot;[dumi](https://d.umijs.org/)&quot;">​</a></h3><p><a href="https://juejin.cn/post/7057365237472690213" target="_blank" rel="noreferrer">dumi搭建组件库并发布npm包</a></p><h3 id="vitepress-相关插件" tabindex="-1"><a href="https://www.baidu.com/s?tn=02003390_97_hao_pg&amp;ie=utf-8&amp;wd=vitepress%20%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6" target="_blank" rel="noreferrer">vitepress 相关插件</a> <a class="header-anchor" href="#vitepress-相关插件" aria-label="Permalink to &quot;[vitepress 相关插件](https://www.baidu.com/s?tn=02003390_97_hao_pg&amp;ie=utf-8&amp;wd=vitepress%20%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6)&quot;">​</a></h3><ul><li><a href="https://www.npmjs.com/search?ranking=popularity&amp;q=vite-demo-preview" target="_blank" rel="noreferrer">vite-demo-preview</a></li><li><a href="https://blog.csdn.net/gitblog_00091/article/details/139314257" target="_blank" rel="noreferrer">推荐使用Vitepress-plugin-search：为您的文档站点添加本地搜索功能</a></li><li><a href="https://blog.csdn.net/cwin8951/article/details/130803402" target="_blank" rel="noreferrer">Vue3 + Vite使用Vitepress编辑基于Element-plus再次封装的Vue3基础组件库文档弃用vitepress-theme-demoblock，使用自己封装的Demo组件</a></li><li><a href="https://blog.csdn.net/cwin8951/article/details/128903971" target="_blank" rel="noreferrer">Vue3+Vite+Element-plus搭建组件库并使用Vitepress编辑组件库文档且发布到 npm并且部署 github pages（vitepress文档渲染.vue组件-推荐使用第二种）</a></li><li><a href="https://juejin.cn/post/7128769888948060191" target="_blank" rel="noreferrer">使用vitepress开发组件文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/450698973" target="_blank" rel="noreferrer">为 vitepress 添加更专业的 Demo 演示能力</a></li></ul>',22),i=[o];function n(p,s,c,h,d,m){return a(),r("div",null,i)}const f=e(l,[["render",n]]);export{b as __pageData,f as default};
