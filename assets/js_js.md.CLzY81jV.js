import{_ as e,c as o,o as t,a2 as a}from"./chunks/framework.BvpWiaHw.js";const h=JSON.parse('{"title":"js","description":"","frontmatter":{},"headers":[],"relativePath":"js/js.md","filePath":"js/js.md"}'),c={name:"js/js.md"},i=a('<h1 id="js" tabindex="-1">js <a class="header-anchor" href="#js" aria-label="Permalink to &quot;js&quot;">​</a></h1><p>包含[ECMAScript,Bom,Dom]</p><p><a href="https://www.jianshu.com/p/2944d346222f" target="_blank" rel="noreferrer">JS-ES-BOM-DOM</a></p><h2 id="ecmascript-es" tabindex="-1">ECMAScript(es) <a class="header-anchor" href="#ecmascript-es" aria-label="Permalink to &quot;ECMAScript(es)&quot;">​</a></h2><ul><li><p>闭包</p></li><li><p>去重 <code>Array.from(new Set([1,1,2,3]))</code></p></li><li><p>闭包 函数内嵌套函数，并且函数执行完后，内部函数会被<code>return返回</code>引用，这样内部函数可以访问外部函数中定义的变量，于是就生成了一个闭包。</p></li><li><p>call apply bind 改变this的指向，用法不同</p><ul><li><code>fn.apply(改变指向后对象, [1, 2]) //立即执行</code></li><li><code>fn.call(改变指向后对象, 1, 2) //立即执行</code></li><li><code>fn.bind(改变指向后对象, 1, 2)() //返回函数本身，不执行</code><ul><li><code>fn.apply(this, arguments)</code></li><li><code>fn.call(this, ...arguments)</code></li></ul></li></ul></li><li><p>typeof <code>&quot;string&quot;</code> | <code>&quot;number&quot;</code> | <code>&quot;boolean&quot;</code> | <code>&quot;undefined&quot;</code> | <code>&quot;object&quot;（对象、数组、null）</code> | <code>&quot;function&quot;</code></p></li><li><p>instaceof <code>({}) instanceof Object</code> | <code>[] instanceof Array | Array.isArray([])</code> | <code>(()=&gt;{}) instanceof Function</code></p></li></ul><h2 id="bom" tabindex="-1">Bom <a class="header-anchor" href="#bom" aria-label="Permalink to &quot;Bom&quot;">​</a></h2>',6),l=[i];function r(d,n,s,p,u,_){return t(),o("div",null,l)}const m=e(c,[["render",r]]);export{h as __pageData,m as default};
