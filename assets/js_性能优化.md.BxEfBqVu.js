import{_ as e,c as l,o as a,a4 as i}from"./chunks/framework.JknIMk6Q.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"js/性能优化.md","filePath":"js/性能优化.md"}'),o={name:"js/性能优化.md"},t=i('<h2 id="性能" tabindex="-1"><a href="https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#e05dce83" target="_blank" rel="noreferrer">性能</a> <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;[性能](https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#e05dce83)&quot;">​</a></h2><h2 id="浏览器输入网址到看到页面都发生了什么" tabindex="-1">浏览器输入网址到看到页面都发生了什么 <a class="header-anchor" href="#浏览器输入网址到看到页面都发生了什么" aria-label="Permalink to &quot;浏览器输入网址到看到页面都发生了什么&quot;">​</a></h2><h3 id="网络" tabindex="-1">网络 <a class="header-anchor" href="#网络" aria-label="Permalink to &quot;网络&quot;">​</a></h3><ol><li>浏览器通过网络模块发送请求，三次握手浏览器获得并解析服务器响应返回的内容，加载html文件及文件内包含的外链和多媒体等资源，</li></ol><h3 id="渲染1版" tabindex="-1">渲染1版 <a class="header-anchor" href="#渲染1版" aria-label="Permalink to &quot;渲染1版&quot;">​</a></h3><blockquote><p>重排必定触发重绘</p></blockquote><ul><li><p>渲染主线程(解析html字符串)</p><ol><li>解析dom树，html元素转对象结构</li><li>解析碰到css代码启动预解析器提前下载再解析css形成CSSOM树，<em>不会阻塞渲染</em></li><li>解析碰到js 暂停一切渲染行为，因为js有改变dom的能力，等js执行完再继续渲染行为 <em>阻塞渲染(这才是js会阻塞渲染的原因)</em></li><li>样式计算：叠加、盒模型…</li><li>布局：非隐藏节点在屏幕的几何信息</li><li>分层： will-change: transform <ul><li>为什么transform效率高因为tranform的所有操作都不会影响渲染主线程，只需要从合成线程开始重新执行 （在主渲染线程后的合成线程走）</li></ul></li><li>绘制(painting)：遍历渲染树绘制所有节点，为每一个节点适用对应的样式</li></ol></li><li><p>合成</p><ul><li>还有分块、光栅化、画</li></ul></li></ul><h3 id="渲染2版-流程有前后因果关系" tabindex="-1">渲染2版 (流程有前后因果关系) <a class="header-anchor" href="#渲染2版-流程有前后因果关系" aria-label="Permalink to &quot;渲染2版 (流程有前后因果关系)&quot;">​</a></h3><ul><li>解析html有几个关键操作 <code>解析HTML构建DOM</code>、<code>下载CSS</code>、<code>解析CSS</code>、<code>下载JavaScript</code>、<code>解析并执行JavaScript</code>渲染进程接收到html数据时会先开启 <em>预解析器</em> <code>解析HTML</code>，<code>预加载link和script外链（找到html中的所有外链交给下载进程提前下载）</code><ol><li><em>构建DOM</em> 解析HTML，构建DOM。</li><li><em>构建CSSOM</em> 遇到style标签或者link外链加载好后，解析CSS，构建CSSOM。</li><li><em>遇到script标签，停止解析HTML</em>，等待外链CSS加载并解析完成、内联CSS解析完成后，再执行JavaScript。执行完JavaScript再开始解析HTML。<code>如果外链的script标签有defer/async属性，则该script标签的下载和执行时候不会停止解析HTML</code>。 <ul><li><code>defer</code>属性，JavaScript会等DOMContentLoaded事件触发后再开始执行；</li><li><code>async</code>属性，JavaScript会等下载完再执行。动态创建的标签也会在下载完成后再执行。</li></ul></li></ol></li></ul><blockquote><p>解析的就是为了 <code>构建dom</code> <code>样式计算</code></p></blockquote><ol><li>构建dom树 <em>(耗时)</em></li><li>样式计算 <em>(耗时)</em></li><li>生成布局树</li><li>分层，生成分层树</li><li>主线程给每个图层生成绘制列表，交给合成线程处理</li><li>合成线程将图层分块</li><li>合成线程在光栅化线程池中将图块转成位图</li><li>合成线程发送绘制图块的命令drawquad给浏览器进程</li><li>浏览器根据命令绘制，并显示在显示器上</li></ol><h4 id="延伸扩展知识点阻塞" tabindex="-1">延伸扩展知识点阻塞 <a class="header-anchor" href="#延伸扩展知识点阻塞" aria-label="Permalink to &quot;延伸扩展知识点阻塞&quot;">​</a></h4><ul><li>css解析会阻塞渲染。因为构造渲染树需要CSSOM，因此CSS解析完成是后续工作的先决条件。</li><li>css下载会阻塞js执行，不会阻塞html解析。</li><li>js下载和执行会阻塞html。</li><li>在执行 JavaScript 脚本之前，会先加载并解析页面中的CSS样式（包括link标签和style标签）（如果存在）。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</li><li>defer的js会异步下载执行，不阻塞HTML解析。</li><li>async的js会异步下载，下载完执行，即下载不阻塞HTML解析，但执行阻塞HTML解析。</li></ul><h2 id="长列表的性能优化" tabindex="-1">长列表的性能优化 <a class="header-anchor" href="#长列表的性能优化" aria-label="Permalink to &quot;长列表的性能优化&quot;">​</a></h2><blockquote><p>懒加载，分页，仅展示的数据可使用Object.freeze冻结对象防止vue劫持 减少监听的性能开销，高清图替换成缩略图</p></blockquote><ol><li>懒加载渲染，就是目前移动端常用的上拉触底一次请求加载一部分加到数组后面接着渲染，dom树增加，最好在1000条以内，具体也得看每条数据的复杂程序</li><li>分页加载渲染，就是pc端表格那种形式 只渲染请求到的这页数据</li><li>可视区域渲染，就是只渲染可视区域的数据，预加载前后部分数据防止白屏，非他完全不渲染 使用虚拟列表 vue-virtual-scroller 实现</li></ol><h2 id="v-for-key" tabindex="-1">v-for :key <a class="header-anchor" href="#v-for-key" aria-label="Permalink to &quot;v-for :key&quot;">​</a></h2><ul><li>key 的作用主要是为了高效的更新虚拟DOM</li><li>这个知识点是跟diff <em>(新旧虚拟节点对比算法,寻找差异)</em> 有关的，减少dom操作的开销</li></ul><h3 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h3><ul><li>for循环里的key不推荐用下标索引index 因为当在中间插入一条的话，后面的数据的下标索引全往后推了，这就跟旧的虚拟节点产生了差异，因为旧的虚拟节点上的下标还是之前的，导致往后的数据全都要重新渲染，</li><li>vue相同标签名元素的过渡切换，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。</li></ul><h2 id="vue中data" tabindex="-1">vue中data <a class="header-anchor" href="#vue中data" aria-label="Permalink to &quot;vue中data&quot;">​</a></h2><p>在Vue实例化时候，Vue会把data设置为响应式，即让用户修改data属性时候，依赖这个属性的地方能够被通知到，从而做出响应</p><ul><li>关键词 <em><code>响应式</code></em> <em><code>双向绑定</code></em> <em><code>数据代理</code></em> <em><code>Object.defineProperty()</code></em> <em><code>Proxy</code></em></li><li>data 中的数据都会增加 getter 和 setter，又会收集 watcher，这样还占内存 所以不需要响应式的数据可以直接定义的实例上 组件创建时直接this...= 减少内存占用</li></ul><h2 id="事件委托代理" tabindex="-1">事件委托代理 <a class="header-anchor" href="#事件委托代理" aria-label="Permalink to &quot;事件委托代理&quot;">​</a></h2><ul><li>在监听器数量上和内存占用上都会非常少 在父元素上绑定事件 在每条数据上:data-msg</li></ul><h2 id="节流-防抖" tabindex="-1">节流 &amp; 防抖 <a class="header-anchor" href="#节流-防抖" aria-label="Permalink to &quot;节流 &amp; 防抖&quot;">​</a></h2><ul><li>节流：一段时间内，无论触发了多少次回调，都只执行 <em>一次</em><ul><li>函数节流非常适用于函数被频繁调用的场景，例如：window.onresize() 事件、mousemove 事件、上传进度等情况</li></ul></li><li>防抖：一段时间内，无论触发了多少次回调，都只执行 <em>最后一次</em></li></ul>',27),r=[t];function d(c,s,u,h,n,m){return a(),l("div",null,r)}const b=e(o,[["render",d]]);export{p as __pageData,b as default};
